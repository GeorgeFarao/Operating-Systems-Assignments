ΦΑΡΑΩ ΓΕΩΡΓΙΟΣ	1115201700177

Για να τρέξει το πρόγραμμα δίνω αρχικά γράφω make coordinator,make peers και αν έχει δημιουργηθεί το sem1.key make removekey και έπειτα ./coordinator ./peers x y z w με x= τον αριθμό των entries, y= τον αριθμό των peers, z=τον αριθμό των loops και w= αριθμo readers.

Κάθε φορά που τρέχω το πρόγραμμα χρειάζεται αλλαγή η δεύτερη παράμετρος της ftok.

Στο coordinator.c έχω μια δομή entry όπου κρατάω τον αριθμό των εγγραφών και των αναγνώσεων και ένα δείκτη για char* για τα τα δεδομένα του entry. Αρχικά γίνεται έλεγχος αν έχουν δωθεί αρκετά ορίσματα και αν δεν έχουν επιστρέφετι μήνυμα και το πρόγραμμα τερματίζει. 

Μετά αρχικοποιώ δύο διαμοιραζόμενες μνήμες, μία όπου κρατάω τον συνολικό αριθμό εγγραφών που εγιναν και μια των αντίστοιχων αναγνώσεων. Έπειτα αρχικοποιώ την κοινή μνήμη για κάθε εγγραφή με '0'. Στην συνέχεια καλώ την ftok για να δημιουργήσω ενα κλειδί για το πρόγραμμα,την open για να πάρω το id για το file sem1.key, γράφω την τιμή του κλειδιού στην μεταβλητή key και κλείνω το file. Μετά φτιάχμω με fork τα child processes και για κάθε process εκτελώ με excevp το peers. Αρχικοποιώ τον πίνακα των σημαφόρων με τιμή 1. Η μητρική διεργασία περιμένει τα παιδιά να τελείωσουν την εκτέλεσή τους εκτυπώνει αντίτοιχα μηνύματα. Τέλος εκτυπώνεται ο συνολικός αριθμός των αναγνώσεων και των εγγραφών που έγιναν.

Στο peers.c αρχικά κάνω τα αντίστοιχα βήματα που έκανα και στο coordinator για τα ορίσματα, την διαμοιραζόμενη μνήμη για τις εγγραφες και τις αναγνωσεις και την ανάκτηση της τιμης του κλειδίου. Στις μεταβλητές readcnt και writecnt κρατάω τις αναγνώσεις και τις εγγραφές αωτίστοιχα που έκανε κάθε peer. 'Επειτα σε κάθε επανάληψη αρχικά με rand επιλέγω αν η διεργασία θα κάνει αναγνωση ή εγγραφή και πάλι με rand το entry στο οποιο θα εκτελέσει. Στην περίπτωση της εγγραφής αρχικά παίρνω το την διαμοιραζόμενη μνήμη πυ αντιστοιχεί στο entry και ελέγχω αν περιέχει την τιμή '*'. Αν την περιέχει σημαίνει οτι την ίδια στιγμή το entry αυτό διαβάζεται απο μία αλλη διεργασία και έτσι περιμένω μέχρι ο πόρος να είναι διαθέσιμος. Στην συνέχεια κάνω down το σημαφόρο του αντίστοιχου entry και κάνω sleep την διεργασία για εκθετικό χρόνο με τον τύπο που μας δώθηκε στο μάθημα. Στο τέλος αυξάνω των μετρητή των εγγραφων για την διεργασία αυτη.

Στην περίπτωση της ανάγνωσης παίρνω πάλι την διαμοιραζόμενη μνήμη για το entry και τοποθετώ '*' ετσι ώστε να μην γράψει κάποια διεργασία την ώρα που γίνεται ανάγνωση του entry. Μετά κανω sleep την διεργασία για εκθετικό χρόνο ,οπως και στην εγγραφή, και τέλος αλλάζω την τιμή της διαμοιραζόμενης μνημης.

Και στις αναγνώσεις και στις εγγραφές εκτυπώνω τον χρόνο που χρειάστηκε για να δεσμεύσει η διεργασια τον πορο. Για τον υπολογισμό του χρόνου χρησιμοποιώ τις συναρτήσεις <sys/time.h> και τον τύπο ((secs)  + usecs*10^9) + 0.5;

Στο τέλος του προγράμματος προσθέτω τις εγγραφές και τις αναγνώσεις που έκανε η διεργασία στον συνολικό αριθμό εγγραφών και αναγνώσεων αντίστοιχα και επίσης τις εκτυπώνω.
